/**
 * TypeScript backend server for Weaviate queries
 * Serves the Flask public folder and handles API requests to Weaviate
 * 
 * This folder is completely isolated and does not depend on other project files.
 */

import 'dotenv/config';
import express, { Request, Response } from 'express';
import cors from 'cors';
import path from 'path';
import fs from 'fs';
import weaviate from 'weaviate-ts-client';
import { generateEmbedding } from './embeddings';

const app = express();
const PORT = process.env.PORT || 8080;

// Middleware
app.use(cors());
app.use(express.json());

// Serve static files from Flask public folder (relative to this file)
// src/server.ts is in: weaviate/backend/src/
// Flask public is in: flask_server/public/
const flaskPublicPath = path.join(__dirname, '../../../flask_server/public');
app.use(express.static(flaskPublicPath));

// Redirect root to index.html
app.get('/', (req: Request, res: Response) => {
    res.redirect('/index.html');
});

// Initialize Weaviate client
const weaviateUrl = process.env.WEAVIATE_URL || '';
const weaviateApiKey = process.env.WEAVIATE_API_KEY || '';

if (!weaviateUrl || !weaviateApiKey) {
    console.error('ERROR: WEAVIATE_URL and WEAVIATE_API_KEY must be set in environment variables');
    process.exit(1);
}

// Extract host from URL (remove https:// or http://)
const host = weaviateUrl.replace(/^https?:\/\//, '').replace(/\/$/, '');

// Initialize Weaviate client (using v4 API)
// Type assertion needed due to API differences in TypeScript definitions
const weaviateClient = weaviate.client({
    scheme: 'https',
    host: host,
    apiKey: new weaviate.ApiKey(weaviateApiKey),
}) as any;

// Valid model/record_level combinations (matches Flask server)
const VALID_COMBINATIONS: Record<string, string[]> = {
    'pericope': ['hebrew_st', 'english_st'],
    'verse': ['hebrew_st', 'berit', 'english_st'],
    'agentic_berit': ['berit', 'hebrew_st', 'english_st'],
    'agentic_hebrew_st': ['hebrew_st', 'english_st'],
    'agentic_english_st': ['hebrew_st', 'english_st'],
};

interface VerseRef {
    chapter: number;
    verse: number;
}


interface VerseLookupEntry {
    chapter: number;
    verse: number;
    text: string;  // English
    hebrew: string;
}

// Load verse lookup data (generated by generate_verse_lookup.py)
function loadVerseLookup(filePath: string): VerseLookupEntry[] {
    const content = fs.readFileSync(filePath, 'utf-8');
    return JSON.parse(content);
}

// Helper function to get Hebrew text for verses
function getHebrewForVerses(verseLookup: VerseLookupEntry[], verseRefs: VerseRef[]): string {
    const hebrewParts: string[] = [];
    
    for (const { chapter, verse } of verseRefs) {
        const entry = verseLookup.find(e => 
            e.chapter === chapter && e.verse === verse
        );
        
        if (entry && entry.hebrew) {
            hebrewParts.push(entry.hebrew);
        }
    }
    
    return hebrewParts.join(' ');
}

// Helper function to get English text for verses
function getEnglishForVerses(verseLookup: VerseLookupEntry[], verseRefs: VerseRef[]): string {
    const englishParts: string[] = [];
    
    for (const { chapter, verse } of verseRefs) {
        const entry = verseLookup.find(e => 
            e.chapter === chapter && e.verse === verse
        );
        
        if (entry && entry.text) {
            englishParts.push(entry.text);
        }
    }
    
    return englishParts.join(' ');
}

// API endpoint: /api/search
app.get('/api/search', async (req: Request, res: Response) => {
    try {
        const modelName = req.query.model_name as string || 'hebrew_st';
        const recordLevel = req.query.record_level as string || 'pericope';
        const topK = parseInt(req.query.top_k as string || '10');
        const searchVersesStr = req.query.search_verses as string || '[]';
        
        // Validate combination
        if (!VALID_COMBINATIONS[recordLevel] || !VALID_COMBINATIONS[recordLevel].includes(modelName)) {
            return res.status(400).json({
                error: `Invalid combination: model_name '${modelName}' cannot be used with record_level '${recordLevel}'. ` +
                       `Valid models for ${recordLevel}: ${VALID_COMBINATIONS[recordLevel].join(', ')}`
            });
        }
        
        // Parse search_verses
        let searchVerses: VerseRef[];
        try {
            searchVerses = JSON.parse(searchVersesStr);
        } catch (e: any) {
            return res.status(400).json({ error: `Invalid JSON in search_verses: ${e.message}` });
        }
        
        if (!Array.isArray(searchVerses) || searchVerses.length === 0) {
            return res.status(400).json({ error: 'search_verses must be a non-empty JSON array' });
        }
        
        // Validate verse format
        for (const verse of searchVerses) {
            if (!verse.chapter || verse.verse === undefined) {
                return res.status(400).json({ 
                    error: 'Each verse must be an object with "chapter" and "verse" fields' 
                });
            }
        }
        
        // Get path to verse lookup file (generated by generate_verse_lookup.py)
        // This file should be copied to the backend folder or accessible via path
        const projectRoot = process.env.PROJECT_ROOT || path.join(__dirname, '../../../../');
        const verseLookupPath = path.join(projectRoot, 'understanding_embeddings/data/records/verse_lookup.json');
        
        // Load verse lookup data
        const verseLookup = loadVerseLookup(verseLookupPath);
        
        // Extract search text based on model
        let searchText: string;
        if (['hebrew_st', 'berit'].includes(modelName)) {
            searchText = getHebrewForVerses(verseLookup, searchVerses);
        } else if (modelName === 'english_st') {
            searchText = getEnglishForVerses(verseLookup, searchVerses);
        } else {
            return res.status(400).json({ 
                error: `Invalid model_name: ${modelName}. Must be 'hebrew_st', 'berit', or 'english_st'` 
            });
        }
        
        if (!searchText) {
            return res.status(400).json({ error: 'No text found for the specified verses' });
        }
        
        // Generate embedding using @xenova/transformers
        console.log(`Generating embedding for ${modelName}...`);
        const queryVector = await generateEmbedding(
            searchText,
            modelName as 'hebrew_st' | 'berit' | 'english_st'
        );
        console.log(`Generated embedding with dimension: ${queryVector.length}`);
        
        // Query Weaviate
        const collectionName = `${modelName}_${recordLevel}`;
        const collection = weaviateClient.collections.get(collectionName);
        
        const results = await collection.query.nearVector({
            nearVector: queryVector,
            limit: topK,
            returnMetadata: ['distance'],
        } as any);
        
        // Format results
        const formattedResults = results.objects.map((obj: any) => ({
            id: obj.uuid,
            title: obj.properties.title || '',
            text: obj.properties.text || '',
            hebrew: obj.properties.hebrew || '',
            strongs: obj.properties.strongs || '',
            verses: obj.properties.verses || [],
            score: 1 - (obj.metadata?.distance || 0), // Convert distance to similarity score
        }));
        
        // Get English search text for display
        const englishSearchText = getEnglishForVerses(verseLookup, searchVerses);
        
        res.json({
            english_search_text: englishSearchText,
            results: formattedResults,
        });
        
    } catch (error: any) {
        console.error('Search error:', error);
        res.status(500).json({ error: error.message });
    }
});

// Start server
app.listen(PORT, () => {
    console.log(`Server running on http://localhost:${PORT}`);
    console.log(`Serving static files from: ${flaskPublicPath}`);
});

